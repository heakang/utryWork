1. tcp/ip的三次握手和四次挥手是什么概念，以及状态变化过程？

	所谓的三次握手，就是在建立TCP链接时，需要客户端和服务端总共发送3个包来确认连接的建立；
	第一次握手指明客户端打算连接的服务器的端口，发送完毕后，客户端进入SYN_SEND状态。 第二次握手
服务器发回确认包(ACK)应答。发送完毕后，服务器端进入SYN_RCVD 状态。第三次握手 客户端再次发送确认包(ACK)，发完毕后，客户端进入 ESTABLISHED状态，当服务器端接收到这个包时，也进入ESTABLISHED状态，TCP握手结束。

	四次挥手表示 TCP 断开连接的时候,需要客户端和服务端总共发送 4 个包以确认连接的断开;
	第一次挥手
	假设客户端想要关闭连接，客户端发送一个包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。发送完毕后，客户端进入 FIN_WAIT_1 状态。 
	第二次挥手
	服务器端确认客户端的包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。 
	第三次挥手
	服务器端准备好关闭连接时，向客户端发送结束连接请求。发送完毕后，服务器端进入LAST_ACK状态，等待来自客户端的最后一个ACK。
	第四次挥手 
	客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入TIME_WAIT状态，等待 可能出现的要求重传的ACK包。服务器端接收到这个确认包之后，关闭连接，进入CLOSED状态。 客户端等待了某个固定时间(两个最大段生命周期，2MSL，2 Maximum Segment Lifetime) 之后，没有收到服务器端的ACK，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入CLOSED状态。

2. 建立连接需要3次，为什么断开连接需要4次？

	三次握手是因为因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭 SOCKET(因为可能还有消息没处理完)，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

3. 三次握手有哪些不安全性？

	SYN攻击，Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的 SYN包将长时间占用未连接队列导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。

4. TCP和UDP的区别？TCP是通过什么方式来保证可靠性的
	
	TCP保证接收端务必收到请求，UDP不保证这种可靠性；
	TCP通过建立连接的三次握手，关闭连接的四次挥手即顺序编号和确认（ACK）来实现的可靠性。


5. tcp四层网络模型和osi七层网络模型分别是什么？以及每一层的作用
	CP/IP四层概念模型包含(应用层、传输层、网络层、数据链路层)，OSI七层网络模型包含(应用层、表示层、会话层、传输层、网络层、数据链路层、物理层)；
	应用层发出报文请求，传输层添加TCP头，网络层添加IP头，数据链路层添加MAC头，物理层转化成比特流传输。

6. 什么是滑动窗口协议？它的实现原理是什么？
	滑动窗口(Sliding window)是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题;发送和接受方都会维护一个数据帧的序列，这个序列被称作窗口。凡落在接收窗口内的幀，接收方都必须处理，落在接收窗口外的幀被丢弃。
7. 服务器上TIME_WAIT状态的连接过多，怎么解决？

	保证由客户端主动发起关闭（即做为B端）
    关闭的时候使用RST的方式
    对处于TIME_WAIT状态的TCP允许重用

8. 什么是NIO、BIO、AIO？他们的区别？
	BIO就是普通的IO,同步阻塞IO,NIO是JDK1.4出现的一种new io,可以实现非阻塞，aio是JDK7之后支持的；
	同步阻塞IO（JAVA BIO）： 
    同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。 

	同步非阻塞IO(Java NIO) ：
	同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。用户进程也需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问。 

	异步阻塞IO（Java NIO）：  
    此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问IO是否完成，那么为什么说是阻塞的呢？因为此时是通过select系统调用来完成的，而select函数本身的实现方式是阻塞的，而采用select函数有个好处就是它可以同时监听多个文件句柄（如果从UNP的角度看，select属于同步操作。因为select之后，进程还需要读写数据），从而提高系统的并发性！  

  （Java AIO(NIO.2)）异步非阻塞IO:  
   在此种模式下，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，因为真正的IO读取或者写入操作已经由内核完成了。

9. 了解过多路复用吗？它是一个什么实现原理？
	I/O 多路复用的本质是通过一种机制(系统内核缓冲I/O数据)，让单个进程可以监视多个文件描述符，一旦某个描述符就绪(一般是读就绪或写就绪)，能够通知程序进行相应的读写操作
10. epool和select的区别是什么？
	epoll所能支持的fd上限是操作系统的最大文件句柄，这个数字要远远大于select的默认值1024；
	epoll是基于事件驱动方式来代替select的顺序扫描，因此性能相对来说更高，主要原理是，当被监听的fd中，有fd就绪时，会告知当前进程具体哪一个fd就绪，那么当前进程只需要去从指定的fd上读取数据即可
